"""
Exploit management and execution API endpoints.
"""

from datetime import datetime
from typing import List, Optional, Dict, Any

from fastapi import APIRouter, Depends, HTTPException, status, BackgroundTasks
from pydantic import BaseModel, Field
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_

from ..core.database import get_db_session
from ..core.nats_client import NATSClient
from ..models.exploit import Exploit, ExploitType, ExploitStatus, ExploitExecution, ExecutionStatus
from ..models.user import User, UserRole
from .auth import get_current_user


router = APIRouter(prefix="/api/exploits", tags=["Exploits"])


# Pydantic models
class ExploitCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=200)
    description: Optional[str] = None
    exploit_type: ExploitType
    target_platform: Optional[str] = None
    target_service: Optional[str] = None
    target_version: Optional[str] = None
    cve_id: Optional[str] = None
    code: str = Field(..., min_length=1)
    language: str = Field(..., regex="^(python|ruby|go|bash|powershell)$")
    dependencies: Optional[List[str]] = None
    config_schema: Optional[Dict[str, Any]] = None


class ExploitResponse(BaseModel):
    id: str
    name: str
    description: Optional[str]
    exploit_type: str
    target_platform: Optional[str]
    target_service: Optional[str]
    target_version: Optional[str]
    cve_id: Optional[str]
    language: str
    author: str
    status: str
    verified_by: Optional[str]
    verified_at: Optional[datetime]
    tags: Optional[List[str]]
    created_at: datetime


class ExploitExecutionRequest(BaseModel):
    exploit_id: str
    target_host: str
    target_port: Optional[int] = None
    config: Optional[Dict[str, Any]] = None
    arguments: Optional[List[str]] = None
    project_id: Optional[str] = None


class ExploitExecutionResponse(BaseModel):
    id: str
    exploit_id: str
    user_id: str
    project_id: Optional[str]
    target_host: str
    target_port: Optional[int]
    status: str
    started_at: Optional[datetime]
    completed_at: Optional[datetime]
    success: bool
    session_id: Optional[str]
    output: Optional[str]
    error: Optional[str]


# Initialize clients
nats_client = NATSClient()


@router.post("/", response_model=ExploitResponse)
async def create_exploit(
    exploit_data: ExploitCreate,
    db: AsyncSession = Depends(get_db_session),
    current_user: User = Depends(get_current_user)
):
    """Create new exploit."""
    # Only researchers and admins can create exploits
    if current_user.role not in [UserRole.RESEARCHER, UserRole.ADMIN]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Insufficient permissions"
        )
    
    new_exploit = Exploit(
        name=exploit_data.name,
        description=exploit_data.description,
        exploit_type=exploit_data.exploit_type,
        target_platform=exploit_data.target_platform,
        target_service=exploit_data.target_service,
        target_version=exploit_data.target_version,
        cve_id=exploit_data.cve_id,
        code=exploit_data.code,
        language=exploit_data.language,
        dependencies=exploit_data.dependencies,
        author=current_user.username,
        config_schema=exploit_data.config_schema,
        status=ExploitStatus.DRAFT,
    )
    
    db.add(new_exploit)
    await db.commit()
    await db.refresh(new_exploit)
    
    return ExploitResponse(
        id=str(new_exploit.id),
        name=new_exploit.name,
        description=new_exploit.description,
        exploit_type=new_exploit.exploit_type.value,
        target_platform=new_exploit.target_platform,
        target_service=new_exploit.target_service,
        target_version=new_exploit.target_version,
        cve_id=new_exploit.cve_id,
        language=new_exploit.language,
        author=new_exploit.author,
        status=new_exploit.status.value,
        verified_by=str(new_exploit.verified_by) if new_exploit.verified_by else None,
        verified_at=new_exploit.verified_at,
        tags=new_exploit.tags,
        created_at=new_exploit.created_at,
    )


@router.get("/", response_model=list[ExploitResponse])
async def list_exploits(
    skip: int = 0,
    limit: int = 100,
    exploit_type: Optional[ExploitType] = None,
    status: Optional[ExploitStatus] = None,
    db: AsyncSession = Depends(get_db_session),
    current_user: User = Depends(get_current_user)
):
    """List all exploits."""
    query = select(Exploit)
    
    if exploit_type:
        query = query.where(Exploit.exploit_type == exploit_type)
    if status:
        query = query.where(Exploit.status == status)
    
    query = query.offset(skip).limit(limit).order_by(Exploit.created_at.desc())
    result = await db.execute(query)
    exploits = result.scalars().all()
    
    return [
        ExploitResponse(
            id=str(exploit.id),
            name=exploit.name,
            description=exploit.description,
            exploit_type=exploit.exploit_type.value,
            target_platform=exploit.target_platform,
            target_service=exploit.target_service,
            target_version=exploit.target_version,
            cve_id=exploit.cve_id,
            language=exploit.language,
            author=exploit.author,
            status=exploit.status.value,
            verified_by=str(exploit.verified_by) if exploit.verified_by else None,
            verified_at=exploit.verified_at,
            tags=exploit.tags,
            created_at=exploit.created_at,
        )
        for exploit in exploits
    ]


@router.get("/{exploit_id}", response_model=ExploitResponse)
async def get_exploit(
    exploit_id: str,
    db: AsyncSession = Depends(get_db_session),
    current_user: User = Depends(get_current_user)
):
    """Get exploit details."""
    result = await db.execute(
        select(Exploit).where(Exploit.id == exploit_id)
    )
    exploit = result.scalar_one_or_none()
    
    if not exploit:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Exploit not found"
        )
    
    return ExploitResponse(
        id=str(exploit.id),
        name=exploit.name,
        description=exploit.description,
        exploit_type=exploit.exploit_type.value,
        target_platform=exploit.target_platform,
        target_service=exploit.target_service,
        target_version=exploit.target_version,
        cve_id=exploit.cve_id,
        language=exploit.language,
        author=exploit.author,
        status=exploit.status.value,
        verified_by=str(exploit.verified_by) if exploit.verified_by else None,
        verified_at=exploit.verified_at,
        tags=exploit.tags,
        created_at=exploit.created_at,
    )


@router.post("/{exploit_id}/execute", response_model=ExploitExecutionResponse)
async def execute_exploit(
    exploit_id: str,
    execution_data: ExploitExecutionRequest,
    background_tasks: BackgroundTasks,
    db: AsyncSession = Depends(get_db_session),
    current_user: User = Depends(get_current_user)
):
    """Execute exploit against target."""
    # Get exploit
    result = await db.execute(
        select(Exploit).where(Exploit.id == exploit_id)
    )
    exploit = result.scalar_one_or_none()
    
    if not exploit:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Exploit not found"
        )
    
    # Create execution record
    execution = ExploitExecution(
        exploit_id=exploit_id,
        user_id=current_user.id,
        project_id=execution_data.project_id,
        target_host=execution_data.target_host,
        target_port=execution_data.target_port,
        config=execution_data.config,
        arguments=execution_data.arguments,
        status=ExecutionStatus.PENDING,
    )
    
    db.add(execution)
    await db.commit()
    await db.refresh(execution)
    
    # Execute in background
    background_tasks.add_task(run_exploit, execution.id, db)
    
    return ExploitExecutionResponse(
        id=str(execution.id),
        exploit_id=str(execution.exploit_id),
        user_id=str(execution.user_id),
        project_id=str(execution.project_id) if execution.project_id else None,
        target_host=execution.target_host,
        target_port=execution.target_port,
        status=execution.status.value,
        started_at=execution.started_at,
        completed_at=execution.completed_at,
        success=execution.success,
        session_id=execution.session_id,
        output=execution.output,
        error=execution.error,
    )


@router.get("/{exploit_id}/executions", response_model=list[ExploitExecutionResponse])
async def list_exploit_executions(
    exploit_id: str,
    db: AsyncSession = Depends(get_db_session),
    current_user: User = Depends(get_current_user)
):
    """List executions for an exploit."""
    # Verify exploit exists
    result = await db.execute(
        select(Exploit).where(Exploit.id == exploit_id)
    )
    exploit = result.scalar_one_or_none()
    
    if not exploit:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Exploit not found"
        )
    
    query = select(ExploitExecution).where(
        and_(
            ExploitExecution.exploit_id == exploit_id,
            ExploitExecution.user_id == current_user.id
        )
    ).order_by(ExploitExecution.created_at.desc())
    
    result = await db.execute(query)
    executions = result.scalars().all()
    
    return [
        ExploitExecutionResponse(
            id=str(exec.id),
            exploit_id=str(exec.exploit_id),
            user_id=str(exec.user_id),
            project_id=str(exec.project_id) if exec.project_id else None,
            target_host=exec.target_host,
            target_port=exec.target_port,
            status=exec.status.value,
            started_at=exec.started_at,
            completed_at=exec.completed_at,
            success=exec.success,
            session_id=exec.session_id,
            output=exec.output,
            error=exec.error,
        )
        for exec in executions
    ]


@router.get("/executions/{execution_id}", response_model=ExploitExecutionResponse)
async def get_exploit_execution(
    execution_id: str,
    db: AsyncSession = Depends(get_db_session),
    current_user: User = Depends(get_current_user)
):
    """Get exploit execution details."""
    result = await db.execute(
        select(ExploitExecution).where(
            and_(
                ExploitExecution.id == execution_id,
                ExploitExecution.user_id == current_user.id
            )
        )
    )
    execution = result.scalar_one_or_none()
    
    if not execution:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Execution not found"
        )
    
    return ExploitExecutionResponse(
        id=str(execution.id),
        exploit_id=str(execution.exploit_id),
        user_id=str(execution.user_id),
        project_id=str(execution.project_id) if execution.project_id else None,
        target_host=execution.target_host,
        target_port=execution.target_port,
        status=execution.status.value,
        started_at=execution.started_at,
        completed_at=execution.completed_at,
        success=execution.success,
        session_id=execution.session_id,
        output=execution.output,
        error=execution.error,
    )


# Background execution
async def run_exploit(execution_id: str, db: AsyncSession) -> None:
    """Execute exploit in background."""
    # Get execution record
    result = await db.execute(
        select(ExploitExecution).where(ExploitExecution.id == execution_id)
    )
    execution = result.scalar_one_or_none()
    
    if not execution:
        return
    
    # Get exploit
    result = await db.execute(
        select(Exploit).where(Exploit.id == execution.exploit_id)
    )
    exploit = result.scalar_one_or_none()
    
    if not exploit:
        execution.status = ExecutionStatus.FAILED
        execution.error = "Exploit not found"
        await db.commit()
        return
    
    # Update execution status
    execution.status = ExecutionStatus.RUNNING
    execution.started_at = datetime.utcnow()
    await db.commit()
    
    try:
        # Execute exploit code
        output, error, success = await execute_exploit_code(exploit, execution)
        
        # Update execution results
        execution.status = ExecutionStatus.SUCCESS if success else ExecutionStatus.FAILED
        execution.completed_at = datetime.utcnow()
        execution.success = success
        execution.output = output
        execution.error = error
        
        # Generate session ID if successful
        if success:
            execution.session_id = f"session_{execution_id}_{datetime.utcnow().timestamp()}"
        
    except Exception as e:
        execution.status = ExecutionStatus.FAILED
        execution.completed_at = datetime.utcnow()
        execution.success = False
        execution.error = str(e)
    
    await db.commit()


async def execute_exploit_code(exploit: Exploit, execution: ExploitExecution) -> tuple[str, str, bool]:
    """Execute exploit code safely."""
    try:
        # Create temporary script file
        script_content = exploit.code
        
        # Add configuration parameters
        if execution.config:
            config_str = "\n".join([f"{k} = {repr(v)}" for k, v in execution.config.items()])
            script_content = config_str + "\n\n" + script_content
        
        # Add target parameters
        script_content = f"TARGET_HOST = {repr(execution.target_host)}\n" + \
                        f"TARGET_PORT = {repr(execution.target_port)}\n\n" + \
                        script_content
        
        # Write to temporary file
        import tempfile
        with tempfile.NamedTemporaryFile(mode='w', suffix=f'.{exploit.language}', delete=False) as f:
            f.write(script_content)
            script_path = f.name
        
        # Execute based on language
        if exploit.language == "python":
            cmd = ["python3", script_path]
        elif exploit.language == "ruby":
            cmd = ["ruby", script_path]
        elif exploit.language == "bash":
            cmd = ["bash", script_path]
        elif exploit.language == "powershell":
            cmd = ["pwsh", "-File", script_path]
        else:
            return "", f"Unsupported language: {exploit.language}", False
        
        # Add arguments
        if execution.arguments:
            cmd.extend(execution.arguments)
        
        # Execute with timeout
        import asyncio
        process = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
            timeout=300  # 5 minute timeout
        )
        
        stdout, stderr = await process.communicate()
        
        # Clean up temporary file
        import os
        os.unlink(script_path)
        
        output = stdout.decode() if stdout else ""
        error = stderr.decode() if stderr else ""
        success = process.returncode == 0
        
        return output, error, success
    
    except asyncio.TimeoutError:
        return "", "Execution timeout", False
    except Exception as e:
        return "", str(e), False


@router.delete("/{exploit_id}")
async def delete_exploit(
    exploit_id: str,
    db: AsyncSession = Depends(get_db_session),
    current_user: User = Depends(get_current_user)
):
    """Delete exploit."""
    result = await db.execute(
        select(Exploit).where(Exploit.id == exploit_id)
    )
    exploit = result.scalar_one_or_none()
    
    if not exploit:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Exploit not found"
        )
    
    # Check permissions
    if current_user.role not in [UserRole.ADMIN] and exploit.author != current_user.username:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Insufficient permissions"
        )
    
    await db.delete(exploit)
    await db.commit()
    
    return {"message": "Exploit deleted successfully"}